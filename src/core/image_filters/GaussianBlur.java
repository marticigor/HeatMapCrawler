package core.image_filters;

import core.image_filters.filter_utils.ChunksNotMessedAssertion;
import core.image_filters.filter_utils.ChunksOrWhole;
import ifaces.IColorScheme;
import ifaces.IImageProcesor;
import lib_duke.ImageResource;
import lib_duke.Pixel;

public class GaussianBlur implements IImageProcesor, IColorScheme {

    private int borderSharpenStage;
    private boolean wholeImage;
    private boolean debug;
    private int[] args; //first 4 always chunk, maybe dummy

    public GaussianBlur(boolean w, boolean d, int...intArgs) {
        this.wholeImage = w;
        this.debug = d;
        args = intArgs;
        if (intArgs.length != 5) throw new RuntimeException("Arguments length");
        borderSharpenStage = intArgs[4];
    }

    @Override
    public void doYourThing(ImageResource in , ImageResource out) {

        int borderG = Gaussian.BORDER_GAUS_5;

        int[] values = ChunksOrWhole.decide(args, wholeImage, in .getWidth(), in .getHeight());
        final int xSize = in .getWidth();
        final int ySize = in .getHeight();
        boolean halt = ChunksNotMessedAssertion.assertOK(xSize, ySize, values, borderSharpenStage);
        if (halt) throw new RuntimeException("chunks messed");

        int widthFrom = values[0];
        widthFrom = (widthFrom == 0) ? borderG : widthFrom;
        int widthTo = values[1];
        widthTo = (widthTo == xSize) ? xSize - borderG : widthTo;
        int heightFrom = values[2];
        heightFrom = (heightFrom == 0) ? borderG : heightFrom;
        int heightTo = values[3];
        heightTo = (heightTo == ySize) ? ySize - borderG : heightTo;

        Pixel pixelOut, matrixPixel;

        int r, g, b;
        int matrixX, matrixY;
        int cumulR, cumulG, cumulB;

        if (borderG != borderSharpenStage) throw new RuntimeException("borders");

        if (debug) {
            System.out.println(" var: xSize " + xSize);
            System.out.println(" var: ySize " + ySize);
        }

        //matrix counters
        int countX;
        int countY;

        final int MAX = 255;

        int minXreached = Integer.MAX_VALUE;
        int maxXreached = Integer.MIN_VALUE;
        int minYreached = Integer.MAX_VALUE;
        int maxYreached = Integer.MIN_VALUE;
        
        for (int absX = widthFrom; absX < widthTo; absX++) {
            for (int absY = heightFrom; absY < heightTo; absY++) {

                pixelOut = out.getPixel(absX, absY);

                matrixX = 0;
                matrixY = 0;
                cumulR = 0;
                cumulG = 0;
                cumulB = 0;

                /*
                 * IF TO SLOW ...
                A Gaussian blur effect is typically generated by convolving an image with a kernel
                of Gaussian values. In practice, it is best to take advantage of the Gaussian blurâ€™s
                separable property by dividing the process into two passes. In the first pass,
                a one-dimensional kernel is used to blur the image in only the horizontal
                or vertical direction. In the second pass, the same one-dimensional kernel is used
                to blur in the remaining direction. The resulting effect is the same as convolving
                with a two-dimensional kernel in a single pass, but requires fewer calculations.
				
                https://en.wikipedia.org/wiki/Gaussian_blur
                */

                //iterate kernel

                countX = 0;
                countY = 0;
                for (int absKernelX = absX - borderG; absKernelX < absX + borderG + 1; absKernelX++) {
                    for (int absKernelY = absY - borderG; absKernelY < absY + borderG + 1; absKernelY++) {

                        matrixX = countX;
                        matrixY = countY;

                        if (absKernelX < minXreached) minXreached = absKernelX;
                        if (absKernelY < minYreached) minYreached = absKernelY;
                        if (absKernelX > maxXreached) maxXreached = absKernelX;
                        if (absKernelY > maxYreached) maxYreached = absKernelY;
                        
                        /*
                        if(debug){
                          System.out.println("\n\n var: absX " + absX);
                          System.out.println(" var: absY " + absY);
                          System.out.println(" var: absKernelX " + absKernelX);
                          System.out.println(" var: absKernelY " + absKernelY);
                          System.out.println(" var: matrixX " + matrixX);
                          System.out.println(" var: matrixY " + matrixY);
                        }
                        */

                        matrixPixel = in .getPixel(absKernelX, absKernelY);
                        cumulR += (matrixPixel.getRed() * Gaussian.GAUS_KERNEL_52[matrixX][matrixY]);
                        cumulG += (matrixPixel.getGreen() * Gaussian.GAUS_KERNEL_52[matrixX][matrixY]);
                        cumulB += (matrixPixel.getBlue() * Gaussian.GAUS_KERNEL_52[matrixX][matrixY]);
                        countY++;
                    }
                    countY = 0;
                    countX++;
                }

                r = (int)(((double) cumulR) * Gaussian.NORMALIZE_GAUS_52);
                g = (int)(((double) cumulG) * Gaussian.NORMALIZE_GAUS_52);
                b = (int)(((double) cumulB) * Gaussian.NORMALIZE_GAUS_52);

                if (r > MAX || g > MAX || b > MAX) {
                    System.out.println("CULPRIT R " + r);
                    System.out.println("CULPRIT G " + g);
                    System.out.println("CULPRIT B " + b);
                    System.out.println("CULPRIT MAX " + MAX);
                    throw new RuntimeException("MAX_VALUES_IN_GB");
                }
                pixelOut.setRed(r);
                pixelOut.setGreen(g);
                pixelOut.setBlue(b);
            }
        }
        /*
        System.out.println("_________________________");
        System.out.println("xSize " + xSize);
        System.out.println("ySize " + ySize);
        System.out.println("wFrom " + widthFrom);
        System.out.println("wTo " + widthTo);
        System.out.println("hFrom " + heightFrom);
        System.out.println("hTo " + heightTo);
        System.out.println("minXreached " + minXreached);
        System.out.println("maxXreached " + maxXreached);
        System.out.println("minYreached " + minYreached);
        System.out.println("maxYreached " + maxYreached);
        System.out.println("_________________________");
        */
    }

    static class Gaussian {
        private static final int[][] GAUS_KERNEL_5 = new int[][] {
            {
                2,4,5,4,2
            }, {
                4,9,12,9,4
            }, {
                5,12,15,12,5
            }, {
                4,9,12,9,4
            }, {
                2,4,5,4,2
            }
        };
        private static final double NORMALIZE_GAUS_5 = 1 / 159d;
        private static final byte BORDER_GAUS_5 = 2;
        
        private static final int[][] GAUS_KERNEL_51 = new int[][] {
            {
                0,1,2,1,0
            }, {
                1,2,3,2,1
            }, {
                2,3,9,3,2
            }, {
                1,2,3,2,1
            }, {
                0,1,2,1,0
            }
        };
        private static final double NORMALIZE_GAUS_51 = 1 / 45d;
        private static final byte BORDER_GAUS_51 = 2;
        //private static final byte SIZE_GAUS = 5;
    
    private static final int[][] GAUS_KERNEL_52 = new int[][] {
        {
            0,0,0,0,0
        }, {
            0,2,3,2,0
        }, {
            0,3,9,3,0
        }, {
            0,2,3,2,0
        }, {
            0,0,0,0,0
        }
    };
    private static final double NORMALIZE_GAUS_52 = 1 / 29d;
    private static final byte BORDER_GAUS_52 = 2;
    //private static final byte SIZE_GAUS = 5;
    }
}
